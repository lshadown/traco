void zuker_traco3(){

int c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,c11,c10,c12,c13,c14,c15;


for( c0 = 0; c0 <= floord(N - 2, 8); c0 += 1)
  #pragma omp parallel for
  for( c1 = (c0 + 1) / 2; c1 <= min(c0, (N - 1) / 16); c1 += 1)
    for( c3 = 16 * c0 - 16 * c1 + 1; c3 <= min(min(N - 1, 16 * c1 + 15), 16 * c0 - 16 * c1 + 16); c3 += 1)
      for( c4 = max(0, -c1 + (N + 1) / 16 - 1); c4 <= min((N - 1) / 16, -c1 + (N + c3 - 1) / 16); c4 += 1)
        for( c6 = max(max(-N + 16 * c1 + 1, -N + c3 + 1), -16 * c4 - 14); c6 <= min(min(0, -N + 16 * c1 + 16), c3 - 16 * c4); c6 += 1) {
          if (c3 >= 2 && 2 * c3 >= 16 * c4 + c6 + 3) {
            if (c3 >= 4 && c3 >= 16 * c4 + c6 + 1) {
              if (16 * c4 + c6 + 1 == c3)
                V[(-c3+16*c4+1)][(16*c4+1)] = MIN(W[(-c3+16*c4+1)+1][(-c3+16*c4+2)] + W[(-c3+16*c4+2)+1][(16*c4+1)-1], V[(-c3+16*c4+1)][(16*c4+1)]);
              for( c10 = max(-c3 + 16 * c4 + 3, -c6 + 1); c10 <= min(16 * c4 + 14, c3 - c6 - 2); c10 += 1) {
                for( c12 = max(16 * c4, c10 + 1); c12 <= min(min(16 * c4 + 15, c3 - c6 - 1), c3 + c10 - 3); c12 += 1)
                  V[(-c6)][(c3-c6)] = MIN(V[c10][c12] + EFL[(-c6)][(c3-c6)], V[(-c6)][(c3-c6)]);
                if (c10 >= 16 * c4)
                  W[(-c6)][(c3-c6)] += MIN ( MIN(W[(-c6)][c10], W[c10+1][(c3-c6)]), W[(-c6)][(c3-c6)]);
                if (16 * c4 + c6 + 15 >= c3)
                  V[(-c6)][(c3-c6)] = MIN(W[(-c6)+1][c10] + W[c10+1][(c3-c6)-1], V[(-c6)][(c3-c6)]);
              }
              if (16 * c4 + c6 + 15 >= c3) {
                W[(-c6)][(c3-c6)] += MIN ( MIN(W[(-c6)][(c3-c6-1)], W[(c3-c6-1)+1][(c3-c6)]), W[(-c6)][(c3-c6)]);
              } else {
                W[(-c6)][(c3-c6)] += MIN ( MIN(W[(-c6)][(16*c4+15)], W[(16*c4+15)+1][(c3-c6)]), W[(-c6)][(c3-c6)]);
              }
            } else if (c3 >= 4 && 16 * c4 + c6 == c3) {
              for( c10 = -c3 + 16 * c4 + 1; c10 < 16 * c4 - 1; c10 += 1)
                V[(-c3+16*c4)][16*c4] = MIN(W[(-c3+16*c4)+1][c10] + W[c10+1][16*c4-1], V[(-c3+16*c4)][16*c4]);
            } else if (c3 >= 16 * c4 + c6 + 16) {
              for( c10 = -c6 + 1; c10 <= 16 * c4 + 15; c10 += 1)
                W[(-c6)][(c3-c6)] += MIN ( MIN(W[(-c6)][c10], W[c10+1][(c3-c6)]), W[(-c6)][(c3-c6)]);
            } else {
              if (c3 == 3) {
                if (16 * c4 + c6 <= 1)
                  W[(-c6)][(-c6+3)] += MIN ( MIN(W[(-c6)][(-c6+1)], W[(-c6+1)+1][(-c6+3)]), W[(-c6)][(-c6+3)]);
                V[(-c6)][(-c6+3)] = MIN(W[(-c6)+1][(-c6+1)] + W[(-c6+1)+1][(-c6+3)-1], V[(-c6)][(-c6+3)]);
              }
              if (c3 >= 16 * c4 + c6 + 1)
                W[(-c6)][(c3-c6)] += MIN ( MIN(W[(-c6)][(c3-c6-1)], W[(c3-c6-1)+1][(c3-c6)]), W[(-c6)][(c3-c6)]);
            }
          }
          if (16 * c4 + c6 + 15 >= c3) {
            V[(-c6)][(c3-c6)] = MIN( MIN (V[(-c6)+1][(c3-c6)-1], EHF[(-c6)][(c3-c6)]), V[(-c6)][(c3-c6)]);
            W[(-c6)][(c3-c6)] = MIN( MIN ( MIN ( W[(-c6)+1][(c3-c6)], W[(-c6)][(c3-c6)-1]), V[(-c6)][(c3-c6)]), W[(-c6)][(c3-c6)]);
          }
        }

}
